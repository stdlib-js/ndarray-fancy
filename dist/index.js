"use strict";var h=function(r,e){return function(){return e||r((e={exports:{}}).exports,e),e.exports}};var y=h(function(Ee,V){"use strict";var ur=require("@stdlib/utils-properties-in"),lr=require("@stdlib/array-base-assert-contains").factory,vr=require("@stdlib/ndarray-ctor"),dr=require("@stdlib/ndarray-defaults"),cr=lr(ur(new vr("generic",[0],[],[0],0,dr.get("order"))));V.exports=cr});var m=h(function(Se,U){"use strict";function hr(){return{readonly:!0}}U.exports=hr});var _=h(function(ye,j){"use strict";var fr=/^-?[0-9]+$/;j.exports=fr});var C=h(function(Re,L){"use strict";var pr=require("@stdlib/assert-is-function"),mr=require("@stdlib/string-base-trim"),wr=require("@stdlib/slice-base-str2multislice"),R=require("@stdlib/string-format"),qr=y(),Er=m(),Sr=_();function yr(r,e,s){var o,n,i,t,a,u;if(qr(e))return n=r[e],pr(n)?d:n;if(i=mr(e),o=r.dtype,a=r.shape,t=i[0],t==="M"){if(u=wr(i),u===null)throw new Error(R("invalid operation. Unsupported slice operation. Value: `%s`.",e));if(u.ndims!==a.length)throw new RangeError(R("invalid operation. Number of array dimensions does not match the number of slice dimensions. Array shape: (%s). Slice dimensions: %u.",a.join(","),u.ndims))}else if(i.length!==0)throw t==="S"||Sr.test(i)?new RangeError(R("invalid operation. Number of array dimensions does not match the number of slice dimensions. Array shape: (%s). Slice dimensions: %u.",a.join(","),1)):new Error(R("invalid operation. Unsupported slice operation. Value: `%s`.",e));return new s.constructor(o,r.data,a,r.strides,r.offset,r.order,Er());function d(){var c,v;for(c=[],v=0;v<arguments.length;v++)c.push(arguments[v]);return n.apply(this===s?r:this,c)}}L.exports=yr});var q=h(function(be,D){"use strict";var Rr=require("@stdlib/ndarray-base-buffer"),br=require("@stdlib/array-base-zeros"),gr=m();function _r(r,e,s,o){var n,i;return i=s.length,i===0?n=[0]:n=br(i),new r(e,Rr(e,0),s,n,0,o,gr())}D.exports=_r});var F=h(function(ge,M){"use strict";var Ir=require("@stdlib/ndarray-base-vind2bind"),xr=require("@stdlib/slice-base-length"),Ar=q(),Nr=m();function Vr(r,e,s,o,n,i,t,a){var u=a.start;return u===a.stop?Ar(r,e,[0],t):(i=Ir(o,n,i,t,u,"throw"),o=[xr(a)],n=[n[0]*a.step],new r(e,s,o,n,i,t,Nr()))}M.exports=Vr});var P=h(function(_e,O){"use strict";var Ur=require("@stdlib/assert-is-function"),jr=require("@stdlib/string-base-trim"),Lr=require("@stdlib/slice-base-seq2slice"),Cr=require("@stdlib/slice-base-str2slice"),Dr=require("@stdlib/slice-base-str2multislice"),Mr=require("@stdlib/slice-base-normalize-slice"),Fr=require("@stdlib/slice-base-normalize-multi-slice"),Or=require("@stdlib/ndarray-base-vind2bind"),f=require("@stdlib/string-format"),Pr=y(),Tr=m(),zr=_(),I=F(),E=q();function Br(r,e,s){var o,n,i,t,a,u,d,c,v,p,l;if(Pr(e))return d=r[e],Ur(d)?tr:d;if(v=jr(e),t=r.dtype,a=r.shape,o=r.strides,n=r.offset,u=r.order,i=!1,p=v[0],p==="S"){if(l=Cr(e),l===null)throw new Error(f("invalid operation. Unsupported slice operation. Value: `%s`.",e));if(l=Mr(l,a[0],!0),l.code){if(i)throw new RangeError(f("invalid operation. Slice exceeds array bounds. Array shape: (%s).",a.join(",")));return E(s.constructor,t,[0],u)}return I(s.constructor,t,r.data,a,o,n,u,l)}if(p==="M"){if(l=Dr(v),l===null)throw new Error(f("invalid operation. Unsupported slice operation. Value: `%s`.",e));if(l.ndims!==a.length)throw new RangeError(f("invalid operation. Number of array dimensions does not match the number of slice dimensions. Array shape: (%s). Slice dimensions: %u.",a.join(","),l.ndims));if(l=Fr(l,a,!0),l.code){if(i)throw new RangeError(f("invalid operation. Slice exceeds array bounds. Array shape: (%s).",a.join(",")));return E(s.constructor,t,[0],u)}return I(s.constructor,t,r.data,a,o,n,u,l.data[0])}if(zr.test(v)){if(l=parseInt(v,10),l<0){if(l=a[0]+l,l<0){if(i)throw new RangeError(f("invalid operation. Slice exceeds array bounds. Array shape: (%s).",a.join(",")));return E(s.constructor,t,[],u)}}else if(l>=a[0]){if(i)throw new RangeError(f("invalid operation. Slice exceeds array bounds. Array shape: (%s).",a.join(",")));return E(s.constructor,t,[],u)}return n=Or(a,o,n,u,l,"throw"),new s.constructor(t,r.data,[],[0],n,u,Tr())}if(c=v.split(/\s*,\s*/),c.length>1)throw new RangeError(f("invalid operation. Number of array dimensions does not match the number of slice dimensions. Array shape: (%s). Slice dimensions: %u.",a.join(","),c.length));if(v=c[0],v.length===0)throw new RangeError(f("invalid operation. Number of array dimensions does not match the number of slice dimensions. Array shape: (%s). Slice dimensions: %u.",a.join(","),0));if(l=Lr(v,a[0],!0),l.code){if(l.code==="ERR_SLICE_OUT_OF_BOUNDS"){if(i)throw new RangeError(f("invalid operation. Slice exceeds array bounds. Array shape: (%s).",a.join(",")));return E(s.constructor,t,[],u)}if(l.code==="ERR_SLICE_INVALID_INCREMENT")throw new Error(f("invalid operation. A subsequence increment must be a non-zero integer. Value: `%s`.",e));if(l.code==="ERR_SLICE_INVALID_SUBSEQUENCE")throw new Error(f("invalid operation. Unsupported slice operation. Value: `%s`.",e))}return I(s.constructor,t,r.data,a,o,n,u,l);function tr(){var g,S;for(g=[],S=0;S<arguments.length;S++)g.push(arguments[S]);return d.apply(this===s?r:this,g)}}O.exports=Br});var z=h(function(Ie,T){"use strict";var Gr=/:/;T.exports=Gr});var G=h(function(xe,B){"use strict";var x=require("@stdlib/string-base-replace");function Qr(r){return r=x(r,/^,/,"null,"),r=x(r,/,$/,",null"),r=x(r,/,(?=,)/g,",null"),"MultiSlice("+r+")"}B.exports=Qr});var W=h(function(Ae,Q){"use strict";function Wr(r){var e,s,o;for(e=r.data,s=[],o=0;o<e.length;o++)typeof e[o]!="number"&&s.push(o);return s}Q.exports=Wr});var k=h(function(Ne,$){"use strict";var $r=require("@stdlib/ndarray-base-sub2ind");function kr(r,e,s,o){var n,i,t;for(n=r.data,i=[e,s,o],t=0;t<n.length;t++)i.push(n[t].start);return i.push("throw"),$r.apply(null,i)}$.exports=kr});var J=h(function(Ve,H){"use strict";function Hr(r,e,s){var o,n,i,t;for(o=r.data,n=[],i=0;i<s.length;i++)t=s[i],n.push(e[t]*o[t].step);return n}H.exports=Hr});var Z=h(function(Ue,Y){"use strict";var Jr=require("@stdlib/slice-base-normalize-multi-slice"),Kr=require("@stdlib/slice-base-shape"),K=require("@stdlib/array-base-take"),Xr=require("@stdlib/ndarray-base-vind2bind"),Yr=require("@stdlib/ndarray-base-numel"),A=require("@stdlib/string-format"),Zr=W(),re=k(),ee=J(),X=m(),ie=q();function ne(r,e,s,o){var n,i,t,a,u,d,c,v,p;if(o===null)throw new Error(A("invalid operation. Unsupported slice operation. Value: `%s`.",e));if(a=r.dtype,u=r.shape,n=r.strides,i=r.offset,d=r.order,t=!1,o.ndims!==u.length)throw new RangeError(A("invalid operation. Number of array dimensions does not match the number of slice dimensions. Array shape: (%s). Slice dimensions: %u.",u.join(","),o.ndims));if(o=Jr(o,u,!0),o.code&&t)throw new RangeError(A("invalid operation. Slice exceeds array bounds. Array shape: (%s).",u.join(",")));return v=s.constructor,p=Kr(o),c=Zr(o),Yr(p)===0?ie(v,a,K(p,c),d):(i=Xr(u,n,i,d,re(o,u,n,0),"throw"),p=K(p,c),p.length===0?new v(a,r.data,[],[0],i,d,X()):(n=ee(o,n,c),new v(a,r.data,p,n,i,d,X())))}Y.exports=ne});var ir=h(function(je,er){"use strict";var ae=require("@stdlib/assert-is-function"),oe=require("@stdlib/string-base-trim"),rr=require("@stdlib/slice-base-str2multislice"),se=require("@stdlib/slice-base-seq2multislice"),b=require("@stdlib/string-format"),te=y(),ue=z(),le=G(),N=Z(),ve=q();function de(r,e,s){var o,n,i,t,a,u;if(te(e))return i=r[e],ae(i)?d:i;if(t=oe(e),o=!1,a=t[0],a==="M")return N(r,e,s,rr(t));if(ue.test(t)){if(n=r.shape,u=se(t,n,!0),u.code){if(u.code==="ERR_SLICE_OUT_OF_BOUNDS"){if(o)throw new RangeError(b("invalid operation. Slice exceeds array bounds. Array shape: (%s).",n.join(",")));return ve(s.constructor,r.dtype,[],r.order)}if(u.code==="ERR_SLICE_INVALID_INCREMENT")throw new Error(b("invalid operation. A subsequence increment must be a non-zero integer. Value: `%s`.",e));if(u.code==="ERR_SLICE_INVALID_ELLIPSIS")throw new Error(b("invalid operation. A subsequence may only include a single ellipsis. Value: `%s`.",e));if(u.code==="ERR_SLICE_INVALID_SUBSEQUENCE")throw new Error(b("invalid operation. Unsupported slice operation. Value: `%s`.",e))}return N(r,e,s,u)}return N(r,"["+e+"]",s,rr(le(t)));function d(){var c,v;for(c=[],v=0;v<arguments.length;v++)c.push(arguments[v]);return i.apply(this===s?r:this,c)}}er.exports=de});var sr=h(function(Le,or){"use strict";var ce=require("@stdlib/utils-define-nonenumerable-read-only-property"),ar=require("@stdlib/ndarray-ctor"),he=require("@stdlib/utils-inherit"),nr=require("@stdlib/proxy-ctor"),fe=C(),pe=P(),me=ir();function w(r,e,s,o,n,i,t){var a,u,d;return u=arguments.length,this instanceof w?(ar.call(this,r,e,s,o,n,i,u<7?{}:t),nr?(d=s.length,a={},d===0?a.get=fe:d===1?a.get=pe:a.get=me,new nr(this,a)):(console.warn("WARNING: Proxy objects are not supported in the current environment. Some `FancyArray` functionality may not be available."),this)):u<7?new w(r,e,s,o,n,i):new w(r,e,s,o,n,i,t)}he(w,ar);ce(w,"name","ndarray");or.exports=w});var we=sr();module.exports=we;
/**
* @license Apache-2.0
*
* Copyright (c) 2023 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=index.js.map
